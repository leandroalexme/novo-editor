Object.defineProperty(exports,"__esModule",{value:!0}),exports.UndoManager=void 0;const t=require("mobx-state-tree"),e=require("../utils/deep-equal");Object.assign(t.types),exports.UndoManager=t.types.model("UndoManager",{history:t.types.array(t.types.frozen()),undoIdx:-1,targetPath:""}).views((t=>({get canUndo(){return t.undoIdx>0},get canRedo(){return t.undoIdx<t.history.length-1}}))).actions((o=>{let a,n,r=!1,s=null,d=0,i=0;const u=()=>i>0;function c(){const e=(0,t.getSnapshot)(a);return{pages:e.pages,width:e.width,height:e.height,custom:e.custom,audios:e.audios}}function h(o){const n=a.pages.map((t=>t.id)),r=o.pages.map((t=>t.id)),s=!(0,e.deepEqual)(n,r),d=!(0,e.deepEqual)(a.custom,o.custom);s?(0,t.applySnapshot)(a.pages,o.pages):a.pages.forEach(((e,a)=>{(0,t.applySnapshot)(e,o.pages[a])})),d&&a.set({custom:o.custom}),a.setSize(o.width,o.height)}return{startTransaction(){i++},endTransaction(t){i--,t||this.requestAddState(c())},async ignore(t,e=!1,a=!1){a&&await new Promise((t=>setTimeout(t,10))),d&&o.addUndoState();let n=u();o.startTransaction();let r=i;try{await t()}catch(h){setTimeout((()=>{throw h}))}const s=r!==i,c=!s;o.endTransaction(c),e||n||o.replaceState(),s||(clearTimeout(d),d=0)},async transaction(t){await o.ignore(t,!0),this.addUndoState()},requestAddState(t){s=t,d||u()||(r?r=!1:d=setTimeout((()=>{d=0,clearTimeout(d),u()||this.addUndoState()}),100))},addUndoState(){if(r){return void(r=!1)}const t=o.history[o.undoIdx];!(0,e.deepEqual)(s,t)&&(clearTimeout(d),d=0,o.history.splice(o.undoIdx+1),o.history.push(s),o.undoIdx=o.history.length-1)},afterCreate(){if(a=(0,t.resolvePath)(o,".."),!a){throw new Error("Failed to find target store for UndoManager. Please provide `targetPath` property, or a `targetStore` in the environment")}n=(0,t.onSnapshot)(a,(()=>{this.requestAddState(c())})),0===o.history.length&&this.requestAddState(c())},clear(){clearTimeout(d),d=0,o.history.splice(0,o.history.length),o.undoIdx=-1,o.addUndoState(c())},beforeDestroy(){n()},undo(){d&&this.addUndoState(),o.canUndo?(o.undoIdx--,r=!0,h(o.history[o.undoIdx])):console.warn("No undo history. Please check `store.history.canUndo` before calling undo action.")},redo(){d&&this.addUndoState(),o.canRedo?(o.undoIdx++,r=!0,h(o.history[o.undoIdx])):console.warn("No redo history. Please check `store.history.canRedo` before calling redo action.")},replaceState(){o.history[o.undoIdx]=c()}}})),exports.default=exports.UndoManager;