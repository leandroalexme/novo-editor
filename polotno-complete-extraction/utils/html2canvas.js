var e,t=this&&this.__createBinding||(Object.create?function(e,t,n,i){void 0===i&&(i=n);var r=Object.getOwnPropertyDescriptor(t,n);r&&!("get"in r?!t.__esModule:r.writable||r.configurable)||(r={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,i,r)}:function(e,t,n,i){void 0===i&&(i=n),e[i]=t[n]}),n=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),i=this&&this.__importStar||(e=function(t){return e=Object.getOwnPropertyNames||function(e){var t=[];for(var n in e){Object.prototype.hasOwnProperty.call(e,n)&&(t[t.length]=n)}return t},e(t)},function(i){if(i&&i.__esModule){return i}var r={};if(null!=i){for(var o=e(i),l=0;l<o.length;l++){"default"!==o[l]&&t(r,i,o[l])}}return n(r,i),r});Object.defineProperty(exports,"__esModule",{value:!0}),exports.prerenderFont=exports.resetStyleContent=void 0,exports.isContentWrapping=function({html:e}){const t=document.createElement("div");t.innerHTML=e,t.style.display="inline-block",t.style.position="fixed",t.style.top="0px",t.style.left="0px",t.style.zIndex="1000",t.style.whiteSpace="nowrap",t.style.visibility="hidden";const n=d();n.appendChild(t);const i=t.textContent,r=t.childNodes[0],o=(null==i?void 0:i.split(/\s+/))||[];let l=!1;for(let s=0;s<o.length;s++){const e=o[s];if(r&&(r.textContent=e,l=r.scrollWidth>t.clientWidth,l)){break}}return n.removeChild(t),l},exports.detectSize=function(e){const t=document.createElement("div");t.innerHTML=e,t.style.display="inline-block",t.style.position="fixed",t.style.top="0px",t.style.left="0px",t.style.zIndex="1000";const n=d();n.appendChild(t);const i=t.getBoundingClientRect();return n.removeChild(t),{width:i.width,height:i.height}},exports.htmlToCanvas=async function({html:e,width:t,height:n,fontFamily:i,padding:c,font:d,pixelRatio:p}){let u="";if("Arial"!==i&&!d){const e=(0,o.getGoogleFontsVariants)();u=await async function(e,t){const n=`${e}|${t}`;if(g.has(n)){return g.get(n)}const i=`https://fonts.googleapis.com/css?family=${e}:${t}&display=swap`,r=await(await fetch(i)).text();return g.set(n,r),r}(i,e)}if(d){const e=d.styles||(d.url?[{src:`url("${d.url}")`}]:h(i));u="",e.forEach((e=>{u+=`\n      @font-face {\n        font-family: '${i}';\n        src: ${e.src};\n        font-style: ${e.fontStyle||"normal"};\n        font-weight: ${e.fontWeight||"normal"};\n      }\n    `}))}let m="";u&&(m=(0,s.optimizeCss)(u,e)),e+=m+a;const y=t+2*c,w=n+2*c,v=document.createElement("canvas"),b=await r.drawHTML(`<div style="padding: ${c}px;" dir="auto">${e}</div>`,v,{width:y,height:w,cacheBucket:f});(0,l.trySetCanvasSize)(v,y*p,w*p);const x=v.getContext("2d");return null==x||x.drawImage(b.image,0,0,y,w,0,0,v.width,v.height),v};const r=i(require("rasterizehtml")),o=require("./fonts"),l=require("./canvas"),s=require("./css-optimizer");exports.resetStyleContent="\n  p {\n    margin: 0;\n    padding: 0;\n    word-wrap: break-word; /* Required for Firefox */\n    /* a text may have several spaces, we need to preserve them */\n    white-space: pre-wrap;\n  }\n\n  /* Reset default list styles and setup counters */\n  ul, ol {\n    list-style: none; /* Remove default markers */\n    padding-inline-start: 0; /* Reset padding */\n    margin: 0;\n    display: block; /* Use block instead of inline-block for better text wrapping */\n    width: 100%;\n    text-decoration: inherit;\n    counter-reset: ol-counter; /* Initialize counter for ol */\n  }\n\n  li {\n    position: relative; /* Needed for absolute positioning of ::before */\n    padding-inline-start: 2.1em; /* Space for the marker (start side) */\n    margin: 0; /* Reset default li margins */\n    word-wrap: break-word; /* Required for Firefox text wrapping */\n    white-space: pre-wrap; /* Preserve spaces and allow wrapping */\n  }\n\n  li::before {\n    content: ''; /* Base content */\n    position: absolute;\n    /* Use logical properties for positioning */\n    inset-inline-start: 0; /* Position marker at the start edge (left in LTR, right in RTL) */\n    top: 0; /* Adjust vertical alignment */\n    /* Prevent letter-spacing from affecting the marker */\n    letter-spacing: normal;\n    /* Define width to ensure consistent spacing and alignment */\n    display: inline-block;\n    width: 2em; /* Width for the marker container */\n    /* Align multi-digit numbers to the end (right in LTR, left in RTL) */\n    text-align: end; \n    /* Space between marker and text (using logical property) */\n    margin-inline-end: 0.8em; /* Pushes text away from marker (2.5em total = 1.7em width + 0.8em margin)*/\n    /* Prevent marker style from inheriting list item styles */\n    font-weight: normal;\n    font-style: normal;\n  }\n\n  /* Style for bullet points */\n  ul > li::before {\n    content: 'â€¢'; /* Literal bullet character */\n    /* Center the bullet within its allocated width */\n    text-align: center; /* Override text-align: end for bullets */\n    font-size: 1.2em;\n    top: 0em; /* Re-adjust vertical alignment for bullet */\n    /* Bullets don't need number alignment, width can be tighter */\n    width: 2em;\n    /* Adjust margin to maintain overall padding */\n    margin-inline-end: 1.5em; /* 2.5em total padding = 1em width + 1.5em margin */\n  }\n\n  /* Style for numbers using counter */\n  ol > li {\n    counter-increment: ol-counter; /* Increment counter for each li in ol */\n  }\n\n  ol > li::before {\n    content: counter(ol-counter) \".\"; /* Display counter value + dot */\n  }\n\n  .ql-indent-1 {\n    margin-inline-start: 0.5em;\n  }\n  .ql-indent-2 {\n    margin-inline-start: 1em;\n  }\n  .ql-indent-3 {\n    margin-inline-start: 1.5em;\n  }\n";const a=`\n<style>\n  html, body {\n    padding: 0;\n    margin: 0;\n  }\n  ${exports.resetStyleContent}\n</style>\n`;let c;const d=()=>(c||(c=document.createElement("div"),c.id="polotno-hidden-do-not-touch",c.style.overflow="hidden",c.style.position="relative",document.body.appendChild(c),c.innerHTML=`<style>#polotno-hidden-do-not-touch {${exports.resetStyleContent}}</style>`),c),p=new Map,u=navigator.userAgent.includes("Firefox");exports.prerenderFont=async e=>{if(p.has(e)){return p.get(e)}const t=(async()=>{const t=`<div style="font-family: ${e}; font-size: 100px;">${e}<strong>${e}</strong></div>`,n=document.createElement("div");n.innerHTML=t,n.style.visibility="hidden",n.style.position="absolute";const i=d();i.appendChild(n);const r=u?180:50;await new Promise((e=>setTimeout(e,r))),i.removeChild(n)})();return p.set(e,t),t};const f={},m={},h=e=>{if(m[e]){return m[e]}const t=function(e){const t=[];for(let i=0;i<document.styleSheets.length;i++){const r=document.styleSheets[i];try{const n=r.cssRules;if(n){for(let i=0;i<n.length;i++){const r=n[i];r instanceof CSSFontFaceRule&&r.style.fontFamily.replace(/['"]/g,"")===e&&t.push(r)}}}catch(n){console.warn(`Could not access stylesheet: ${r.href}`,n)}}return t}(e),n=t.filter((t=>t.style.fontFamily.replace(/['"]/g,"")===e)).map((e=>({src:e.style.getPropertyValue("src"),fontStyle:e.style.getPropertyValue("font-style")||"normal",fontWeight:e.style.getPropertyValue("font-weight")||"normal"})));return m[e]=n,n},g=new Map;